var k={allRenderFn:!1,cmpDidLoad:!0,cmpDidUnload:!1,cmpDidUpdate:!0,cmpDidRender:!0,cmpWillLoad:!0,cmpWillUpdate:!0,cmpWillRender:!0,connectedCallback:!0,disconnectedCallback:!0,element:!0,event:!0,hasRenderFn:!0,lifecycle:!0,hostListener:!0,hostListenerTargetWindow:!0,hostListenerTargetDocument:!0,hostListenerTargetBody:!0,hostListenerTargetParent:!1,hostListenerTarget:!0,member:!0,method:!0,mode:!0,observeAttribute:!0,prop:!0,propMutable:!0,reflect:!0,scoped:!0,shadowDom:!0,slot:!0,cssAnnotations:!0,state:!0,style:!0,formAssociated:!1,svg:!0,updatable:!0,vdomAttribute:!0,vdomXlink:!0,vdomClass:!0,vdomFunctional:!0,vdomKey:!0,vdomListener:!0,vdomRef:!0,vdomPropOrAttr:!0,vdomRender:!0,vdomStyle:!0,vdomText:!0,watchCallback:!0,taskQueue:!0,hotModuleReplacement:!1,isDebug:!1,isDev:!1,isTesting:!1,hydrateServerSide:!1,hydrateClientSide:!1,lifecycleDOMEvents:!1,lazyLoad:!1,profile:!1,slotRelocation:!0,appendChildSlotFix:!1,cloneNodeFix:!1,hydratedAttribute:!1,hydratedClass:!0,scriptDataOpts:!1,scopedSlotTextContentFix:!1,shadowDomShim:!1,slotChildNodesFix:!1,invisiblePrehydration:!0,propBoolean:!0,propNumber:!0,propString:!0,constructableCSS:!0,cmpShouldUpdate:!0,devTools:!1,shadowDelegatesFocus:!0,initializeNextTick:!1,asyncLoading:!1,asyncQueue:!1,transformTagName:!1,attachStyles:!0,experimentalSlotFixes:!1},Ee=Object.defineProperty,_e=(e,t)=>{for(var s in t)Ee(e,s,{get:t[s],enumerable:!0})},St={isDev:!1,isBrowser:!0,isServer:!1,isTesting:!1},$e=new WeakMap,x=e=>$e.get(e),we=(e,t)=>{const s={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};return $e.set(e,s)},J=(e,t)=>t in e,N=(e,t)=>(0,console.error)(e,t),j=new Map,ce=[],Re="slot-fb{display:contents}slot-fb[hidden]{display:none}",Y="http://www.w3.org/1999/xlink",U=typeof window<"u"?window:{},m=U.document||{head:{}},kt=U.HTMLElement||class{},h={$flags$:0,$resourcesUrl$:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,s,r)=>e.addEventListener(t,s,r),rel:(e,t,s,r)=>e.removeEventListener(t,s,r),ce:(e,t)=>new CustomEvent(e,t)},bt=e=>{Object.assign(h,e)},Ae=(()=>{let e=!1;try{m.addEventListener("e",null,Object.defineProperty({},"passive",{get(){e=!0}}))}catch(t){}return e})(),Oe=e=>Promise.resolve(e),Ne=(()=>{try{return new CSSStyleSheet,typeof new CSSStyleSheet().replaceSync=="function"}catch(e){}return!1})(),B=!1,H=[],fe=[],de=(e,t)=>s=>{e.push(s),B||(B=!0,t&&h.$flags$&4?Ue(z):h.raf(z))},Z=e=>{for(let t=0;t<e.length;t++)try{e[t](performance.now())}catch(s){N(s)}e.length=0},z=()=>{Z(H),Z(fe),(B=H.length>0)&&h.raf(z)},Ue=e=>Oe().then(e),Tt=de(H,!1),Pe=de(fe,!0),xt=e=>{const t=new URL(e,h.$resourcesUrl$);return t.origin!==U.location.origin?t.href:t.pathname},V={},je="http://www.w3.org/2000/svg",Ce="http://www.w3.org/1999/xhtml",Fe=e=>e!=null,I=e=>(e=typeof e,e==="object"||e==="function");function De(e){var t,s,r;return(r=(s=(t=e.head)==null?void 0:t.querySelector('meta[name="csp-nonce"]'))==null?void 0:s.getAttribute("content"))!=null?r:void 0}var Me={};_e(Me,{err:()=>ue,map:()=>Be,ok:()=>W,unwrap:()=>He,unwrapErr:()=>ze});var W=e=>({isOk:!0,isErr:!1,value:e}),ue=e=>({isOk:!1,isErr:!0,value:e});function Be(e,t){if(e.isOk){const s=t(e.value);return s instanceof Promise?s.then(r=>W(r)):W(s)}if(e.isErr){const s=e.value;return ue(s)}throw"should never get here"}var He=e=>{if(e.isOk)return e.value;throw e.value},ze=e=>{if(e.isErr)return e.value;throw e.value},E=(e,t="")=>()=>{},ve=(e,t,...s)=>{let r=null,l=null,n=null,a=!1,i=!1;const o=[],d=$=>{for(let f=0;f<$.length;f++)r=$[f],Array.isArray(r)?d(r):r!=null&&typeof r!="boolean"&&((a=typeof e!="function"&&!I(r))&&(r=String(r)),a&&i?o[o.length-1].$text$+=r:o.push(a?C(null,r):r),i=a)};if(d(s),t){t.key&&(l=t.key),t.name&&(n=t.name);{const $=t.className||t.class;$&&(t.class=typeof $!="object"?$:Object.keys($).filter(f=>$[f]).join(" "))}}if(typeof e=="function")return e(t===null?{}:t,o,Ie);const u=C(e,null);return u.$attrs$=t,o.length>0&&(u.$children$=o),u.$key$=l,u.$name$=n,u},C=(e,t)=>{const s={$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null};return s.$attrs$=null,s.$key$=null,s.$name$=null,s},We={},qe=e=>e&&e.$tag$===We,Ie={forEach:(e,t)=>e.map(ee).forEach(t),map:(e,t)=>e.map(ee).map(t).map(Qe)},ee=e=>({vattrs:e.$attrs$,vchildren:e.$children$,vkey:e.$key$,vname:e.$name$,vtag:e.$tag$,vtext:e.$text$}),Qe=e=>{if(typeof e.vtag=="function"){const s={...e.vattrs};return e.vkey&&(s.key=e.vkey),e.vname&&(s.name=e.vname),ve(e.vtag,s,...e.vchildren||[])}const t=C(e.vtag,e.vtext);return t.$attrs$=e.vattrs,t.$children$=e.vchildren,t.$key$=e.vkey,t.$name$=e.vname,t},Xe=e=>ce.map(t=>t(e)).find(t=>!!t),Lt=e=>ce.push(e),Et=e=>x(e).$modeName$,Ge=(e,t)=>e!=null&&!I(e)?t&4?e==="false"?!1:e===""||!!e:t&2?parseFloat(e):t&1?String(e):e:e,Ke=e=>e,_t=(e,t,s)=>{const r=Ke(e);return{emit:l=>Je(r,t,{bubbles:!!(s&4),composed:!!(s&2),cancelable:!!(s&1),detail:l})}},Je=(e,t,s)=>{const r=h.ce(t,s);return e.dispatchEvent(r),r},te=new WeakMap,Ye=(e,t,s)=>{let r=j.get(e);Ne&&s?(r=r||new CSSStyleSheet,typeof r=="string"?r=t:r.replaceSync(t)):r=t,j.set(e,r)},Ze=(e,t,s)=>{var r;const l=he(t,s),n=j.get(l);if(e=e.nodeType===11?e:m,n)if(typeof n=="string"){e=e.head||e;let a=te.get(e),i;if(a||te.set(e,a=new Set),!a.has(l)){{i=m.createElement("style"),i.innerHTML=n;const o=(r=h.$nonce$)!=null?r:De(m);o!=null&&i.setAttribute("nonce",o),e.insertBefore(i,e.querySelector("link"))}t.$flags$&4&&(i.innerHTML+=Re),a&&a.add(l)}}else e.adoptedStyleSheets.includes(n)||(e.adoptedStyleSheets=[...e.adoptedStyleSheets,n]);return l},Ve=e=>{const t=e.$cmpMeta$,s=e.$hostElement$,r=t.$flags$,l=E("attachStyles",t.$tagName$),n=Ze(s.shadowRoot?s.shadowRoot:s.getRootNode(),t,e.$modeName$);r&10&&(s["s-sc"]=n,s.classList.add(n+"-h"),r&2&&s.classList.add(n+"-s")),l()},he=(e,t)=>"sc-"+(t&&e.$flags$&32?e.$tagName$+"-"+t:e.$tagName$),se=(e,t,s,r,l,n)=>{if(s!==r){let a=J(e,t),i=t.toLowerCase();if(t==="class"){const o=e.classList,d=re(s),u=re(r);o.remove(...d.filter($=>$&&!u.includes($))),o.add(...u.filter($=>$&&!d.includes($)))}else if(t==="style"){for(const o in s)(!r||r[o]==null)&&(o.includes("-")?e.style.removeProperty(o):e.style[o]="");for(const o in r)(!s||r[o]!==s[o])&&(o.includes("-")?e.style.setProperty(o,r[o]):e.style[o]=r[o])}else if(t!=="key")if(t==="ref")r&&r(e);else if(!e.__lookupSetter__(t)&&t[0]==="o"&&t[1]==="n"){if(t[2]==="-"?t=t.slice(3):J(U,i)?t=i.slice(2):t=i[2]+t.slice(3),s||r){const o=t.endsWith(pe);t=t.replace(tt,""),s&&h.rel(e,t,s,o),r&&h.ael(e,t,r,o)}}else{const o=I(r);if((a||o&&r!==null)&&!l)try{if(e.tagName.includes("-"))e[t]=r;else{const u=r==null?"":r;t==="list"?a=!1:(s==null||e[t]!=u)&&(e[t]=u)}}catch(u){}let d=!1;i!==(i=i.replace(/^xlink\:?/,""))&&(t=i,d=!0),r==null||r===!1?(r!==!1||e.getAttribute(t)==="")&&(d?e.removeAttributeNS(Y,t):e.removeAttribute(t)):(!a||n&4||l)&&!o&&(r=r===!0?"":r,d?e.setAttributeNS(Y,t,r):e.setAttribute(t,r))}}},et=/\s/,re=e=>e?e.split(et):[],pe="Capture",tt=new RegExp(pe+"$"),ge=(e,t,s)=>{const r=t.$elm$.nodeType===11&&t.$elm$.host?t.$elm$.host:t.$elm$,l=e&&e.$attrs$||V,n=t.$attrs$||V;for(const a of le(Object.keys(l)))a in n||se(r,a,l[a],void 0,s,t.$flags$);for(const a of le(Object.keys(n)))se(r,a,l[a],n[a],s,t.$flags$)};function le(e){return e.includes("ref")?[...e.filter(t=>t!=="ref"),"ref"]:e}var _,q,A,F=!1,D=!1,Q=!1,y=!1,M=(e,t,s,r)=>{var l;const n=t.$children$[s];let a=0,i,o,d;if(F||(Q=!0,n.$tag$==="slot"&&(_&&r.classList.add(_+"-s"),n.$flags$|=n.$children$?2:1)),n.$text$!==null)i=n.$elm$=m.createTextNode(n.$text$);else if(n.$flags$&1)i=n.$elm$=m.createTextNode("");else{if(y||(y=n.$tag$==="svg"),i=n.$elm$=m.createElementNS(y?je:Ce,!F&&k.slotRelocation&&n.$flags$&2?"slot-fb":n.$tag$),y&&n.$tag$==="foreignObject"&&(y=!1),ge(null,n,y),Fe(_)&&i["s-si"]!==_&&i.classList.add(i["s-si"]=_),G(i,r),n.$children$)for(a=0;a<n.$children$.length;++a)o=M(e,n,a,i),o&&i.appendChild(o);n.$tag$==="svg"?y=!1:i.tagName==="foreignObject"&&(y=!0)}return i["s-hn"]=A,n.$flags$&3&&(i["s-sr"]=!0,i["s-cr"]=q,i["s-sn"]=n.$name$||"",i["s-rf"]=(l=n.$attrs$)==null?void 0:l.ref,d=e&&e.$children$&&e.$children$[s],d&&d.$tag$===n.$tag$&&e.$elm$&&O(e.$elm$,!1)),i},O=(e,t)=>{h.$flags$|=1;const s=Array.from(e.childNodes);if(e["s-sr"]&&k.experimentalSlotFixes){let r=e;for(;r=r.nextSibling;)r&&r["s-sn"]===e["s-sn"]&&r["s-sh"]===A&&s.push(r)}for(let r=s.length-1;r>=0;r--){const l=s[r];l["s-hn"]!==A&&l["s-ol"]&&(T(Se(l),l,X(l)),l["s-ol"].remove(),l["s-ol"]=void 0,l["s-sh"]=void 0,Q=!0),t&&O(l,t)}h.$flags$&=-2},ye=(e,t,s,r,l,n)=>{let a=e["s-cr"]&&e["s-cr"].parentNode||e,i;for(a.shadowRoot&&a.tagName===A&&(a=a.shadowRoot);l<=n;++l)r[l]&&(i=M(null,s,l,e),i&&(r[l].$elm$=i,T(a,i,X(t))))},me=(e,t,s)=>{for(let r=t;r<=s;++r){const l=e[r];if(l){const n=l.$elm$;Te(l),n&&(D=!0,n["s-ol"]?n["s-ol"].remove():O(n,!0),n.remove())}}},st=(e,t,s,r,l=!1)=>{let n=0,a=0,i=0,o=0,d=t.length-1,u=t[0],$=t[d],f=r.length-1,c=r[0],v=r[f],S,g;for(;n<=d&&a<=f;)if(u==null)u=t[++n];else if($==null)$=t[--d];else if(c==null)c=r[++a];else if(v==null)v=r[--f];else if(P(u,c,l))w(u,c,l),u=t[++n],c=r[++a];else if(P($,v,l))w($,v,l),$=t[--d],v=r[--f];else if(P(u,v,l))(u.$tag$==="slot"||v.$tag$==="slot")&&O(u.$elm$.parentNode,!1),w(u,v,l),T(e,u.$elm$,$.$elm$.nextSibling),u=t[++n],v=r[--f];else if(P($,c,l))(u.$tag$==="slot"||v.$tag$==="slot")&&O($.$elm$.parentNode,!1),w($,c,l),T(e,$.$elm$,u.$elm$),$=t[--d],c=r[++a];else{for(i=-1,o=n;o<=d;++o)if(t[o]&&t[o].$key$!==null&&t[o].$key$===c.$key$){i=o;break}i>=0?(g=t[i],g.$tag$!==c.$tag$?S=M(t&&t[a],s,i,e):(w(g,c,l),t[i]=void 0,S=g.$elm$),c=r[++a]):(S=M(t&&t[a],s,a,e),c=r[++a]),S&&T(Se(u.$elm$),S,X(u.$elm$))}n>d?ye(e,r[f+1]==null?null:r[f+1].$elm$,s,r,a,f):a>f&&me(t,n,d)},P=(e,t,s=!1)=>e.$tag$===t.$tag$?e.$tag$==="slot"?e.$name$===t.$name$:s?!0:e.$key$===t.$key$:!1,X=e=>e&&e["s-ol"]||e,Se=e=>(e["s-ol"]?e["s-ol"]:e).parentNode,w=(e,t,s=!1)=>{const r=t.$elm$=e.$elm$,l=e.$children$,n=t.$children$,a=t.$tag$,i=t.$text$;let o;i===null?(y=a==="svg"?!0:a==="foreignObject"?!1:y,a==="slot"&&!F||ge(e,t,y),l!==null&&n!==null?st(r,l,t,n,s):n!==null?(e.$text$!==null&&(r.textContent=""),ye(r,null,t,n,0,n.length-1)):l!==null&&me(l,0,l.length-1),y&&a==="svg"&&(y=!1)):(o=r["s-cr"])?o.parentNode.textContent=i:e.$text$!==i&&(r.data=i)},ke=e=>{const t=e.childNodes;for(const s of t)if(s.nodeType===1){if(s["s-sr"]){const r=s["s-sn"];s.hidden=!1;for(const l of t)if(l!==s){if(l["s-hn"]!==s["s-hn"]||r!==""){if(l.nodeType===1&&(r===l.getAttribute("slot")||r===l["s-sn"])||l.nodeType===3&&r===l["s-sn"]){s.hidden=!0;break}}else if(l.nodeType===1||l.nodeType===3&&l.textContent.trim()!==""){s.hidden=!0;break}}}ke(s)}},b=[],be=e=>{let t,s,r;for(const l of e.childNodes){if(l["s-sr"]&&(t=l["s-cr"])&&t.parentNode){s=t.parentNode.childNodes;const n=l["s-sn"];for(r=s.length-1;r>=0;r--)if(t=s[r],!t["s-cn"]&&!t["s-nr"]&&t["s-hn"]!==l["s-hn"]&&!k.experimentalSlotFixes)if(ne(t,n)){let a=b.find(i=>i.$nodeToRelocate$===t);D=!0,t["s-sn"]=t["s-sn"]||n,a?(a.$nodeToRelocate$["s-sh"]=l["s-hn"],a.$slotRefNode$=l):(t["s-sh"]=l["s-hn"],b.push({$slotRefNode$:l,$nodeToRelocate$:t})),t["s-sr"]&&b.map(i=>{ne(i.$nodeToRelocate$,t["s-sn"])&&(a=b.find(o=>o.$nodeToRelocate$===t),a&&!i.$slotRefNode$&&(i.$slotRefNode$=a.$slotRefNode$))})}else b.some(a=>a.$nodeToRelocate$===t)||b.push({$nodeToRelocate$:t})}l.nodeType===1&&be(l)}},ne=(e,t)=>e.nodeType===1?e.getAttribute("slot")===null&&t===""||e.getAttribute("slot")===t:e["s-sn"]===t?!0:t==="",Te=e=>{e.$attrs$&&e.$attrs$.ref&&e.$attrs$.ref(null),e.$children$&&e.$children$.map(Te)},T=(e,t,s)=>{const r=e==null?void 0:e.insertBefore(t,s);return G(t,e),r},xe=e=>{const t=[];return e&&t.push(...e["s-scs"]||[],e["s-si"],e["s-sc"],...xe(e.parentElement)),t},G=(e,t,s=!1)=>{var r;if(e&&t&&e.nodeType===1){const l=new Set(xe(t).filter(Boolean));if(l.size&&((r=e.classList)==null||r.add(...e["s-scs"]=[...l]),e["s-ol"]||s))for(const n of Array.from(e.childNodes))G(n,e,!0)}},rt=(e,t,s=!1)=>{var r,l,n,a,i;const o=e.$hostElement$,d=e.$cmpMeta$,u=e.$vnode$||C(null,null),$=qe(t)?t:ve(null,null,t);if(A=o.tagName,d.$attrsToReflect$&&($.$attrs$=$.$attrs$||{},d.$attrsToReflect$.map(([f,c])=>$.$attrs$[c]=o[f])),s&&$.$attrs$)for(const f of Object.keys($.$attrs$))o.hasAttribute(f)&&!["key","ref","style","class"].includes(f)&&($.$attrs$[f]=o[f]);$.$tag$=null,$.$flags$|=4,e.$vnode$=$,$.$elm$=u.$elm$=o.shadowRoot||o,_=o["s-sc"],F=(d.$flags$&1)!==0,q=o["s-cr"],D=!1,w(u,$,s);{if(h.$flags$|=1,Q){be($.$elm$);for(const f of b){const c=f.$nodeToRelocate$;if(!c["s-ol"]){const v=m.createTextNode("");v["s-nr"]=c,T(c.parentNode,c["s-ol"]=v,c)}}for(const f of b){const c=f.$nodeToRelocate$,v=f.$slotRefNode$;if(v){const S=v.parentNode;let g=v.nextSibling;{let L=(r=c["s-ol"])==null?void 0:r.previousSibling;for(;L;){let p=(l=L["s-nr"])!=null?l:null;if(p&&p["s-sn"]===c["s-sn"]&&S===p.parentNode){for(p=p.nextSibling;p===c||p!=null&&p["s-sr"];)p=p==null?void 0:p.nextSibling;if(!p||!p["s-nr"]){g=p;break}}L=L.previousSibling}}(!g&&S!==c.parentNode||c.nextSibling!==g)&&c!==g&&(!c["s-hn"]&&c["s-ol"]&&(c["s-hn"]=c["s-ol"].parentNode.nodeName),T(S,c,g),c.nodeType===1&&(c.hidden=(n=c["s-ih"])!=null?n:!1)),c&&typeof v["s-rf"]=="function"&&v["s-rf"](c)}else c.nodeType===1&&(s&&(c["s-ih"]=(a=c.hidden)!=null?a:!1),c.hidden=!0)}}D&&ke($.$elm$),h.$flags$&=-2,b.length=0}if(k.experimentalScopedSlotChanges&&d.$flags$&2)for(const f of $.$elm$.childNodes)f["s-hn"]!==A&&!f["s-sh"]&&(s&&f["s-ih"]==null&&(f["s-ih"]=(i=f.hidden)!=null?i:!1),f.hidden=!0);q=void 0},lt=(e,t)=>{},K=(e,t)=>(e.$flags$|=16,lt(e,e.$ancestorComponent$),Pe(()=>nt(e,t))),nt=(e,t)=>{const s=e.$hostElement$,r=E("scheduleUpdate",e.$cmpMeta$.$tagName$),l=s;if(!l)throw new Error("Can't render component <".concat(s.tagName.toLowerCase()," /> with invalid Stencil runtime! Make sure this imported component is compiled with a `externalRuntime: true` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime"));let n;return t?n=R(l,"componentWillLoad"):n=R(l,"componentWillUpdate"),n=ae(n,()=>R(l,"componentWillRender")),r(),ae(n,()=>ot(e,l,t))},ae=(e,t)=>at(e)?e.then(t).catch(s=>{console.error(s),t()}):t(),at=e=>e instanceof Promise||e&&e.then&&typeof e.then=="function",ot=async(e,t,s)=>{const r=e.$hostElement$,l=E("update",e.$cmpMeta$.$tagName$);r["s-rc"],s&&Ve(e);const n=E("render",e.$cmpMeta$.$tagName$);it(e,t,r,s),n(),l(),$t(e)},oe=null,it=(e,t,s,r)=>{try{oe=t,t=t.render&&t.render(),e.$flags$&=-17,e.$flags$|=2,(k.hasRenderFn||k.reflect)&&(k.vdomRender||k.reflect)&&(k.hydrateServerSide||rt(e,t,r))}catch(o){N(o,e.$hostElement$)}return oe=null,null},$t=e=>{const t=e.$cmpMeta$.$tagName$,s=e.$hostElement$,r=E("postUpdate",t),l=s;e.$ancestorComponent$,R(l,"componentDidRender"),e.$flags$&64?(R(l,"componentDidUpdate"),r()):(e.$flags$|=64,R(l,"componentDidLoad"),r())},wt=e=>{{const t=x(e),s=t.$hostElement$.isConnected;return s&&(t.$flags$&18)===2&&K(t,!1),s}},R=(e,t,s)=>{if(e&&e[t])try{return e[t](s)}catch(r){N(r)}},ct=(e,t)=>x(e).$instanceValues$.get(t),ft=(e,t,s,r)=>{const l=x(e),n=e,a=l.$instanceValues$.get(t),i=l.$flags$,o=n;s=Ge(s,r.$members$[t][0]);const d=Number.isNaN(a)&&Number.isNaN(s);if(s!==a&&!d){l.$instanceValues$.set(t,s);{if(r.$watchers$&&i&128){const $=r.$watchers$[t];$&&$.map(f=>{try{o[f](s,a,t)}catch(c){N(c,n)}})}if((i&18)===2){if(o.componentShouldUpdate&&o.componentShouldUpdate(s,a,t)===!1)return;K(l,!1)}}}},dt=(e,t,s)=>{var r,l;const n=e.prototype;if(t.$members$||t.$watchers$||e.watchers){e.watchers&&!t.$watchers$&&(t.$watchers$=e.watchers);const a=Object.entries((r=t.$members$)!=null?r:{});a.map(([i,[o]])=>{(o&31||o&32)&&Object.defineProperty(n,i,{get(){return ct(this,i)},set(d){ft(this,i,d,t)},configurable:!0,enumerable:!0})});{const i=new Map;n.attributeChangedCallback=function(o,d,u){h.jmp(()=>{var $;const f=i.get(o);if(this.hasOwnProperty(f))u=this[f],delete this[f];else{if(n.hasOwnProperty(f)&&typeof this[f]=="number"&&this[f]==u)return;if(f==null){const c=x(this),v=c==null?void 0:c.$flags$;if(v&&!(v&8)&&v&128&&u!==d){const g=this,L=($=t.$watchers$)==null?void 0:$[o];L==null||L.forEach(p=>{g[p]!=null&&g[p].call(g,u,d,o)})}return}}this[f]=u===null&&typeof this[f]=="boolean"?!1:u})},e.observedAttributes=Array.from(new Set([...Object.keys((l=t.$watchers$)!=null?l:{}),...a.filter(([o,d])=>d[0]&15).map(([o,d])=>{var u;const $=d[1]||o;return i.set($,o),d[0]&512&&((u=t.$attrsToReflect$)==null||u.push([o,$])),$})]))}}return e},ut=async(e,t,s,r)=>{let l;if(!(t.$flags$&32)){t.$flags$|=32,s.$lazyBundleId$;{l=e.constructor;const a=e.localName;customElements.whenDefined(a).then(()=>t.$flags$|=128)}if(l&&l.style){let a;typeof l.style=="string"?a=l.style:typeof l.style!="string"&&(t.$modeName$=Xe(e),t.$modeName$&&(a=l.style[t.$modeName$]));const i=he(s,t.$modeName$);if(!j.has(i)){const o=E("registerStyles",s.$tagName$);Ye(i,a,!!(s.$flags$&1)),o()}}}t.$ancestorComponent$,K(t,!0)},ie=e=>{},vt=e=>{if(!(h.$flags$&1)){const t=x(e),s=t.$cmpMeta$,r=E("connectedCallback",s.$tagName$);t.$flags$&1?(Le(e,t,s.$listeners$),t!=null&&t.$lazyInstance$?ie(t.$lazyInstance$):t!=null&&t.$onReadyPromise$&&t.$onReadyPromise$.then(()=>ie(t.$lazyInstance$))):(t.$flags$|=1,s.$flags$&12&&ht(e),s.$members$&&Object.entries(s.$members$).map(([l,[n]])=>{if(n&31&&e.hasOwnProperty(l)){const a=e[l];delete e[l],e[l]=a}}),ut(e,t,s)),r()}},ht=e=>{const t=e["s-cr"]=m.createComment("");t["s-cn"]=!0,T(e,t,e.firstChild)},pt=async e=>{if(!(h.$flags$&1)){const t=x(e);t.$rmListeners$&&(t.$rmListeners$.map(s=>s()),t.$rmListeners$=void 0)}},Rt=(e,t)=>{const s={$flags$:t[0],$tagName$:t[1]};s.$members$=t[2],s.$listeners$=t[3],s.$watchers$=e.$watchers$,s.$attrsToReflect$=[];const r=e.prototype.connectedCallback,l=e.prototype.disconnectedCallback;return Object.assign(e.prototype,{__registerHost(){we(this,s)},connectedCallback(){const n=x(this);Le(this,n,s.$listeners$),vt(this),r&&r.call(this)},disconnectedCallback(){pt(this),l&&l.call(this)},__attachShadow(){if(!this.shadowRoot)this.attachShadow({mode:"open",delegatesFocus:!!(s.$flags$&16)});else if(this.shadowRoot.mode!=="open")throw new Error("Unable to re-use existing shadow root for ".concat(s.$tagName$,"! Mode is set to ").concat(this.shadowRoot.mode," but Stencil only supports open shadow roots."))}}),e.is=s.$tagName$,dt(e,s)},Le=(e,t,s,r)=>{s&&s.map(([l,n,a])=>{const i=yt(e,l),o=gt(t,a),d=mt(l);h.ael(i,n,o,d),(t.$rmListeners$=t.$rmListeners$||[]).push(()=>h.rel(i,n,o,d))})},gt=(e,t)=>s=>{var r;try{k.lazyLoad||e.$hostElement$[t](s)}catch(l){N(l)}},yt=(e,t)=>t&4?m:t&8?U:t&16?m.body:e,mt=e=>Ae?{passive:(e&1)!==0,capture:(e&2)!==0}:(e&2)!==0;export{St as B,kt as H,Lt as a,We as b,xt as c,_t as d,wt as f,Et as g,ve as h,Rt as p,Tt as r,bt as s,Pe as w};
